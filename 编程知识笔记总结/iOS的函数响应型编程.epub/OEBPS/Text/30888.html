<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <title>iOS的函数响应型编程 - 书栈(BookStack.CN)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../Styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../Styles/page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre6">
    <h1 id="article-title" class="calibre11">总结</h1>
    <div class="article-body" id="page-content">
        <div class="markdown-toc"><ul class="markdown-toc-list"><li class="calibre12"><a class="pcalibre1 calibre9 pcalibre" href="#总结" level="1">总结</a><ul class="calibre13"></ul></li>
</ul>
</div>
<h1 id="h1-u603Bu7ED3" class="calibre14"><a class="pcalibre1 calibre9 pcalibre" id="总结"></a><span class="pcalibre2 header-link"></span>总结</h1>
<p class="calibre15">本章我们使用<code class="calibre20 pcalibre6 pcalibre5">ReactiveCocoa</code>做了很多实践，总结了几个关键点：</p>
<ul class="markdown-toc-list">
<li class="calibre12">函数式编程可在任何地方起作用<ul class="calibre13">
<li class="calibre12">数据导入的代码，即使没有反应式代码，我们也能够使用<code class="calibre23 pcalibre6 pcalibre5">map:</code>和<code class="calibre23 pcalibre6 pcalibre5">filter:</code>来帮忙。在抽象方面，总觉得从未被实际实现。</li>
</ul>
</li>
</ul>
<ul class="markdown-toc-list">
<li class="calibre12">为函数的副作用使用<code class="calibre23 pcalibre6 pcalibre5">subscribeNext:</code><ul class="calibre13">
<li class="calibre12"><code class="calibre23 pcalibre6 pcalibre5">subscribeNext:</code>和其他类似的方法订阅信号的副作用，返回<code class="calibre23 pcalibre6 pcalibre5">RACDisposable</code>实例（这种实例将被传阅，直到信号完成被回收为止）<br class="calibre18"/>为副作用使用这些方法—-使得事物看起来像主动跟外界(一个没有反应式的世界)交互似的。</li>
</ul>
</li>
</ul>
<ul class="markdown-toc-list">
<li class="calibre12"><p class="calibre25">避免显示状态下进行订阅处理</p>
<ul class="calibre13">
<li class="calibre12">按照设计准则，无论何时都应该避免显示的订阅处理。请记住我们是怎样用<code class="calibre23 pcalibre6 pcalibre5">takeUntil:</code>来自动处理<code class="calibre23 pcalibre6 pcalibre5">FRPCell</code>类的订阅的。使用<code class="calibre23 pcalibre6 pcalibre5">takeUntil:</code>允许信号值通过，直到它的参数被传递下去或者它自己的值完成。基本上这种情况下，接收者已经完成接收了。</li>
</ul>
</li>
<li class="calibre12"><p class="calibre25">内存管理的魔法</p>
<ul class="calibre13">
<li class="calibre12">ARC下，在代码的表面上你摆脱了内存管理。<code class="calibre23 pcalibre6 pcalibre5">ReactiveCocoa</code>中也一样。唯一要注意的是，不能在任何signal的block中捕捉self。</li>
</ul>
</li>
</ul>
<p class="calibre15">以上，就是第五章的全部内容。接下来我们将介绍Model-View-ViewModel这种程序架构，给App添加一个日志系统，并写一些单元测试，出发吧！</p>
<blockquote class="calibre16">
<p class="calibre15">BTY:函数副作用：指当调用函数时，除了返回函数值之外，还对主调用函数产生附加影响。例如修改全局变量或修改参数，一般而言函数副作用会给程序设计带来不必要的麻烦，使程序难以查找错误，并降低程序的可读性。严格的函数式语言要求函数必须无副作用。</p>
<p class="calibre17">有一种特殊的情况，就是我们这里的函数。它的参数是一种In/Out作用的参数，即函数可能改变参数里面的内容，把一些信息通过输入参数，夹带到外界。这种情况，严格来说，也是副作用，是非纯函数。即我们所讨论的函数反应型编程中的函数式编程属于非纯函数，它是具有副作用的。</p>
</blockquote>

    </div>
</body>
</html>