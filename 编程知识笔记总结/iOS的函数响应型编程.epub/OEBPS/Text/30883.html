<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
  "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" lang="zh-CN" xml:lang="zh-CN">
<head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>
    <title>iOS的函数响应型编程 - 书栈(BookStack.CN)</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
  <link href="../Styles/stylesheet.css" rel="stylesheet" type="text/css"/>
<link href="../Styles/page_styles.css" rel="stylesheet" type="text/css"/>
</head>
  <body class="calibre6">
    <h1 id="article-title" class="calibre11">信号</h1>
    <div class="article-body" id="page-content">
        <div class="markdown-toc"><ul class="markdown-toc-list"><li class="calibre12"><a class="pcalibre1 calibre9 pcalibre" href="#信号" level="1">信号</a><ul class="calibre13"></ul></li>
</ul>
</div>
<h1 id="h1-u4FE1u53F7" class="calibre14"><a class="pcalibre1 calibre9 pcalibre" id="信号"></a><span class="pcalibre2 header-link"></span>信号</h1>
<p class="calibre15">信号是另一种类型的流。与序列流相反，信号是<code class="calibre20 pcalibre6 pcalibre5">push-driven</code>的。新的值能够通过管道发布但不能像<code class="calibre20 pcalibre6 pcalibre5">pull-driven</code>一样在管道中获取，他们所抽象出来的数据会在未来的某个时间传送过来。</p>
<p class="calibre15">这里需要理解两个概念:<code class="calibre20 pcalibre6 pcalibre5">pull-driven</code>和<code class="calibre20 pcalibre6 pcalibre5">push-driven</code>.</p>
<blockquote class="calibre16">
<p class="calibre15">Push-driven means that values for the signal are not defined at the moment of signal creation and may become available at a later time (for example, as a result from network request, or any user input).</p>
<p class="calibre15">Push-driven : 在创建信号的时候，信号不会被立即赋值，之后才会被赋值(举个栗子：网络请求回来的结果或者是任意的用户输入的结果)</p>
<p class="calibre15">Pull-driven means that values in the sequence are defined at the moment of signal creation and we can query values from the stream one-by-one.</p>
<p class="calibre17">Pull-driven : 在创建信号的同时序列中的值就会被确定下来，我们可以从流中一个个地查询值。</p>
</blockquote>
<p class="calibre15">信号发送三种类型的值：<code class="calibre20 pcalibre6 pcalibre5">Next Values</code>代表了下一个发送到管道内的值。<code class="calibre20 pcalibre6 pcalibre5">Error Value</code>代表<code class="calibre20 pcalibre6 pcalibre5">signal</code>无法成功完成,一般很少见，我们会在下一章学习怎么使用她们。<code class="calibre20 pcalibre6 pcalibre5">Completion Values</code>代表<code class="calibre20 pcalibre6 pcalibre5">signal</code>成功完成，我们也会在下一章来学习。这里要注意的是：</p>
<blockquote class="calibre16">
<p class="calibre17">一个事情响应中，一个<code class="calibre21 pcalibre6 pcalibre5">signal</code>(信号)发送了一个<code class="calibre21 pcalibre6 pcalibre5">Error value</code>或者一个<code class="calibre21 pcalibre6 pcalibre5">Completion Value</code>后，就不会再发送任何其他的<code class="calibre21 pcalibre6 pcalibre5">value</code>.<br class="calibre18"/> 错误或者成功将只会发送其中一个，绝不会有两个同时发送的情况！</p>
</blockquote>
<p class="calibre15">信号是ReactiveCocoa的核心组件之一。ReactiveCocoa为UIKit的每一个控件内置了一套信号选择器。例如，UITextField就有一个<code class="calibre20 pcalibre6 pcalibre5">rac_textSignal</code>,UITextField中每一次按键的响应都会通过它发送出去。下一章我们会学习如何使用信号来执行任务。</p>
<p class="calibre15"> <img src="../Images/9a178afc2ad7eb126f95d02bde0cbb35.png" alt="ClassDiagram" class="calibre22"/></p>
<p class="calibre15">信号也可以被链接(链式调用)和转化。通过映射或者过滤一个流得到的新的流也可以随后被映射、被过滤，进行所有你能想到的各种操作。下一章我们将了解更多这方面的内容。</p>

    </div>
</body>
</html>